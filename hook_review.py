# ItemDef_review_hook.py
import os
import json
import re
from datetime import datetime
from docx import Document
from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_TABLE_ALIGNMENT
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
import openpyxl
from openpyxl.styles import Font, PatternFill, Border, Side, Alignment
from openpyxl.utils import get_column_letter
from cat.mad_hatter.decorators import hook
from cat.log import log



def create_review_custom_styles(doc):
    """Define custom styles for Review Document."""
    # Title style
    title_style = doc.styles.add_style("ReviewTitle", 1)
    title_style.base_style = doc.styles["Normal"]
    title_style.font.name = "Calibri"
    title_style.font.size = Pt(24)
    title_style.font.bold = True
    title_style.font.color.rgb = RGBColor(54, 95, 145)
    title_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER
    title_style.paragraph_format.space_after = Pt(12)

    # Subtitle style
    subtitle_style = doc.styles.add_style("ReviewSubtitle", 1)
    subtitle_style.base_style = doc.styles["Normal"]
    subtitle_style.font.name = "Calibri"
    subtitle_style.font.size = Pt(16)
    subtitle_style.font.color.rgb = RGBColor(54, 95, 145)
    subtitle_style.font.italic = True
    subtitle_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER
    subtitle_style.paragraph_format.space_after = Pt(12)

    # Header style for sections
    header_style = doc.styles.add_style("ReviewHeader", 1)
    header_style.base_style = doc.styles["Normal"]
    header_style.font.name = "Calibri"
    header_style.font.size = Pt(14)
    header_style.font.bold = True
    header_style.font.color.rgb = RGBColor(54, 95, 145)
    header_style.paragraph_format.space_before = Pt(12)
    header_style.paragraph_format.space_after = Pt(6)

    # Body style
    body_style = doc.styles.add_style("ReviewBody", 1)
    body_style.base_style = doc.styles["Normal"]
    body_style.font.name = "Calibri"
    body_style.font.size = Pt(10)
    body_style.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
    body_style.paragraph_format.space_after = Pt(6)
    body_style.paragraph_format.line_spacing = 1.15

def add_review_header_footer(doc, plugin_folder):
    """Add header and footer for review document."""
    section = doc.sections[0]
    header = section.header
    footer = section.footer

    # === HEADER ===
    table = header.add_table(rows=1, cols=2, width=Inches(8))
    table.autofit = False
    cell_logo, cell_title = table.rows[0].cells

    # Logo (left)
    image_path = os.path.join(plugin_folder, "templates", "logo.png")
    if os.path.exists(image_path):
        paragraph = cell_logo.paragraphs[0]
        run = paragraph.add_run()
        run.add_picture(image_path, width=Inches(1.5))
        cell_logo.width = Inches(1.5)
    else:
        cell_logo.text = ""

    # Title (right)
    title_para = cell_title.paragraphs[0]
    title_para.alignment = WD_ALIGN_PARAGRAPH.RIGHT
    run = title_para.add_run("ISO 26262 Item Definition Review\nGenerated by Kineton FuSa Agent")
    run.font.size = Pt(10)
    run.font.bold = True
    run.font.color.rgb = RGBColor(54, 95, 145)

    # Light blue line below header
    line_para = header.add_paragraph()
    p = line_para._element
    pPr = p.get_or_add_pPr()
    bottom_border = OxmlElement('w:pBdr')
    pPr.append(bottom_border)
    bottom_line = OxmlElement('w:bottom')
    bottom_line.set(qn('w:val'), 'single')
    bottom_line.set(qn('w:sz'), '10')
    bottom_line.set(qn('w:space'), '1')
    bottom_line.set(qn('w:color'), 'A0C4E8')
    bottom_border.append(bottom_line)

    # === FOOTER ===
    line_para_footer = footer.add_paragraph()
    p_footer = line_para_footer._element
    pPr_footer = p_footer.get_or_add_pPr()
    top_border = OxmlElement('w:pBdr')
    pPr_footer.append(top_border)
    top_line = OxmlElement('w:top')
    top_line.set(qn('w:val'), 'single')
    top_line.set(qn('w:sz'), '6')
    top_line.set(qn('w:space'), '1')
    top_line.set(qn('w:color'), 'D0E3F5')
    top_border.append(top_line)

    # Footer text
    text_para = footer.add_paragraph()
    text_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
    run = text_para.add_run("CONFIDENTIAL ‚Äì ¬© 2025 Kineton. Generated by Kineton FuSa Agent.")
    run.font.size = Pt(8)
    run.font.italic = True
    run.font.color.rgb = RGBColor(128, 128, 128)

def add_section_explanation(doc, category):
    """
    Adds a brief explanation paragraph after each category heading in the Word document.
    """
    explanations = {
        "Identification and Classification": (
            "This section ensures that the item is uniquely identified within the system architecture or documentation "
            "and properly classified (e.g., as hardware, software, or a system function). This supports traceability from "
            "high-level safety goals down to detailed design elements. Clear identification also enables effective configuration "
            "management and version control throughout the development lifecycle. It is a foundational element for ensuring structured functional safety development."
        ),
        "Functional Description": (
            "This section describes the expected behavior of the item under all operating conditions, including normal, degraded, "
            "and fault modes. It includes definitions of interfaces, timing constraints, and performance requirements. A well-defined "
            "functional description is essential for identifying potential failure scenarios and serves as input to hazard analysis. It helps "
            "ensure that all relevant behaviors are considered when deriving safety requirements."
        ),
        "Safety-Related Attributes": (
            "This section captures key safety-related properties such as safety goals, mitigation strategies, diagnostic coverage, "
            "and safe state definitions. These attributes are derived from the Hazard Analysis and Risk Assessment (HARA) and form the basis "
            "of the functional safety concept. They guide the implementation of safety mechanisms and define how the item contributes to overall "
            "system safety. Proper documentation ensures alignment with ISO 26262 expectations for safety integrity."
        ),
        "Dependencies and Interactions": (
            "This section identifies internal and external dependencies, including interactions with other systems, environmental influences, "
            "and user inputs. Understanding these relationships is critical for defining correct assumptions and boundary conditions during development. "
            "It also supports the identification of potential interference or integration risks that could impact safety. Accurate documentation ensures robust "
            "interface management and system integration."
        ),
        "System Boundaries and Context": (
            "This section defines the physical and logical boundaries of the item, along with environmental conditions and design constraints. "
            "It clarifies where the item operates and under what limitations, such as temperature, vibration, or EMC exposure. These details ensure that "
            "the item is developed and validated under realistic assumptions. Defining this context early supports the creation of accurate test plans and operational profiles."
        ),
        "Review and Approval": (
            "This section confirms that a formal review process was followed and that all necessary approvals were obtained before finalizing the item definition. "
            "It verifies that review minutes, action items, and change records are documented and closed. Configuration management practices should also be applied to maintain "
            "document integrity. This ensures process compliance and provides an auditable trail for quality assurance and functional safety governance."
        )
    }

    explanation = explanations.get(category)
    if explanation:
        paragraph = doc.add_paragraph(explanation)
        paragraph.style = 'Normal'
        paragraph.alignment = 0  # Left-aligned
        paragraph.paragraph_format.space_after = Pt(12)
        paragraph.paragraph_format.line_spacing = 1.2

def load_checklist_for_categorization(plugin_folder):
    """
    Load the checklist to get category information for each ID.
    """
    try:
        checklist_path = os.path.join(plugin_folder, "checklists", "item_definition_checklist.json")
        with open(checklist_path, 'r', encoding='utf-8') as f:
            checklist = json.load(f)
        
        # Create a mapping from ID to category
        id_to_category = {}
        for item in checklist.get('items', []):
            item_id = item.get('id', '')
            category = item.get('category', 'General Requirements')
            id_to_category[item_id] = category
        
        return id_to_category
    except Exception as e:
        log.warning(f"Could not load checklist for categorization: {e}")
        return {}
    
def categorize_review_item(review_item, id_to_category_map):
    """
    Categorizes a review item based on its ID using the checklist mapping.
    Falls back to keyword-based categorization if ID not found.
    """
    item_id = review_item.get('id', '').strip()
    
    # First try to get category from checklist mapping
    if item_id in id_to_category_map:
        return id_to_category_map[item_id]
    
    # Fallback to keyword-based categorization
    requirement = review_item.get('requirement', '').lower()
    description = review_item.get('description', '').lower()
    
    # Define keywords for each category
    categories = {
        "Identification and Classification": [
            "identification", "classify", "unique", "id", "type", "component", "module", "function"
        ],
        "Functional Description": [
            "function", "behavior", "operation", "interface", "timing", "performance", "mode", "input", "output"
        ],
        "Safety-Related Attributes": [
            "safety", "asil", "goal", "mitigation", "diagnostic", "safe state", "hazard", "risk", "failure"
        ],
        "Dependencies and Interactions": [
            "depend", "interaction", "external", "internal", "relationship", "integration", "interference"
        ],
        "System Boundaries and Context": [
            "boundary", "context", "environment", "constraint", "limitation", "condition", "assumption"
        ],
        "Review and Approval": [
            "review", "approval", "verification", "validation", "compliance", "audit", "process", "documentation"
        ]
    }
    
    # Check each category
    for category, keywords in categories.items():
        for keyword in keywords:
            if (keyword in requirement or keyword in description or 
                keyword.replace(" ", "_").upper() in item_id):
                return category
    
    # Default category if no match found
    return "General Requirements"

def group_reviews_by_category(reviews, plugin_folder):
    """
    Groups review items by category using checklist data and returns an ordered dictionary.
    """
    # Load the ID to category mapping from checklist
    id_to_category_map = load_checklist_for_categorization(plugin_folder)
    
    # Define the order of categories as they appear in the checklist
    category_order = [
        "Identification and Classification",
        "Functional Description", 
        "Safety-Related Attributes",
        "Dependencies and Interactions",
        "System Boundaries and Context",
        "Review and Approval"
    ]
    
    # Initialize ordered dictionary with empty lists
    categorized = {category: [] for category in category_order}

    # Add a catch-all for any items that don't match known categories
    categorized["General Requirements"] = []
    
    for review in reviews:
        category = categorize_review_item(review, id_to_category_map)
        
        # Ensure the category exists in our dictionary
        if category not in categorized:
            categorized[category] = []
        
        categorized[category].append(review)
    
    return categorized

def parse_review_content(content):
    """Parse the LLM review response into structured data."""
    reviews = []
    
    # Split by review items (looking for **ID:** pattern)
    items = re.split(r'\*\*ID:\*\*', content)
    
    for item in items[1:]:  # Skip first empty split
        review_item = {}
        
        # Extract ID
        id_match = re.search(r'^([^\*]+)', item)
        if id_match:
            review_item['id'] = id_match.group(1).strip()
        
        # Extract Requirement
        req_match = re.search(r'\*\*Requirement:\*\*\s*([^*]+?)(?:\*\*|$)', item)
        if req_match:
            review_item['requirement'] = req_match.group(1).strip()
        
        # Extract Description
        desc_match = re.search(r'\*\*Description:\*\*\s*([^*]+?)(?:\*\*|$)', item)
        if desc_match:
            review_item['description'] = desc_match.group(1).strip()
        
        # Extract Status
        status_match = re.search(r'\*\*Status:\*\*\s*([^*]+?)(?:\*\*|$)', item)
        if status_match:
            review_item['status'] = status_match.group(1).strip()
        
        # Extract Comment
        comment_match = re.search(r'\*\*Comment:\*\*\s*([^*]+?)(?:\*\*|$)', item)
        if comment_match:
            review_item['comment'] = comment_match.group(1).strip()
        
        # Extract Hint for improvement
        hint_match = re.search(r'\*\*Hint for improvement:\*\*\s*([^*]+?)(?:\*\*|$)', item)
        if hint_match:
            review_item['hint'] = hint_match.group(1).strip()
        
        if review_item:
            reviews.append(review_item)
    
    return reviews

def create_review_docx(reviews, plugin_folder, timestamp):
    """Create a formatted Word document with review results, grouped by category with explanations."""
    doc = Document()
    create_review_custom_styles(doc)
    add_review_header_footer(doc, plugin_folder)
    
    # === TITLE PAGE ===
    doc.add_paragraph('ISO 26262 Part 3 - Item Definition Review Report', style="ReviewTitle")
    doc.add_paragraph(f"Review conducted on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", style="ReviewSubtitle")
    doc.add_paragraph()
    doc.add_page_break()
    
    # === SUMMARY TABLE ===
    total_items = len(reviews)
    passed_items = len([r for r in reviews if r.get('status', '').lower() == 'pass'])
    failed_items = len([r for r in reviews if r.get('status', '').lower() == 'fail'])
    partial_items = len([r for r in reviews if 'partial' in r.get('status', '').lower()])
    
    doc.add_paragraph("Review Summary", style="ReviewHeader")
    summary_table = doc.add_table(rows=5, cols=2)
    summary_table.style = 'Table Grid'
    summary_table.alignment = WD_TABLE_ALIGNMENT.CENTER
    
    summary_data = [
        ("Total Requirements Reviewed:", str(total_items)),
        ("Passed:", str(passed_items)),
        ("Failed:", str(failed_items)),
        ("Partially Passed:", str(partial_items)),
        ("Compliance Rate:", f"{(passed_items/total_items)*100:.1f}%" if total_items > 0 else "0%")
    ]
    
    for i, (label, value) in enumerate(summary_data):
        summary_table.rows[i].cells[0].text = label
        summary_table.rows[i].cells[1].text = value
        for cell in summary_table.rows[i].cells:
            cell.paragraphs[0].runs[0].font.size = Pt(10)
            if i == len(summary_data) - 1:
                cell.paragraphs[0].runs[0].font.bold = True
    
    doc.add_page_break()
    
    # === GROUP REVIEWS BY CATEGORY ===
    categorized_reviews = group_reviews_by_category(reviews, plugin_folder)
    
    # === DETAILED REVIEW BY CATEGORY ===
    doc.add_paragraph("Detailed Review Results", style="ReviewHeader")
    doc.add_paragraph()  # Spacing after main header
    
    # Define the expected order (must match group_reviews_by_category)
    category_order = [
        "Identification and Classification",
        "Functional Description", 
        "Safety-Related Attributes",
        "Dependencies and Interactions",
        "System Boundaries and Context",
        "Review and Approval",
        "General Requirements"
    ]
    
    for category in category_order:
        if category not in categorized_reviews or not categorized_reviews[category]:
            continue  # Skip empty categories
        
        # Add category header
        doc.add_paragraph(category, style="ReviewHeader")
        
        # Add explanation paragraph
        add_section_explanation(doc, category)
        
        # Add each review item in this category
        for i, review in enumerate(categorized_reviews[category], 1):
            # Optional: prefix with category short name or number
            doc.add_paragraph(f"{category} ‚Äì Item {i}", style="ReviewHeader")
            
            # Create table for the review item
            table = doc.add_table(rows=6, cols=2)
            table.style = 'Table Grid'
            
            fields = [
                ("ID:", review.get('id', 'N/A')),
                ("Requirement:", review.get('requirement', 'N/A')),
                ("Description:", review.get('description', 'N/A')),
                ("Status:", review.get('status', 'N/A')),
                ("Comment:", review.get('comment', 'N/A')),
                ("Hint for Improvement:", review.get('hint', 'N/A'))
            ]
            
            for j, (field_name, field_value) in enumerate(fields):
                table.rows[j].cells[0].text = field_name
                table.rows[j].cells[1].text = field_value
                
                table.rows[j].cells[0].paragraphs[0].runs[0].font.bold = True
                table.rows[j].cells[0].paragraphs[0].runs[0].font.size = Pt(10)
                table.rows[j].cells[1].paragraphs[0].runs[0].font.size = Pt(10)
                
                # Color code status
                if field_name == "Status:":
                    status_lower = field_value.lower()
                    if 'pass' in status_lower and 'fail' not in status_lower:
                        table.rows[j].cells[1].paragraphs[0].runs[0].font.color.rgb = RGBColor(0, 128, 0)  # Green
                    elif 'fail' in status_lower:
                        table.rows[j].cells[1].paragraphs[0].runs[0].font.color.rgb = RGBColor(255, 0, 0)  # Red
                    elif 'partial' in status_lower:
                        table.rows[j].cells[1].paragraphs[0].runs[0].font.color.rgb = RGBColor(255, 165, 0)  # Orange
            
            doc.add_paragraph()  # Space between items
        
        doc.add_paragraph()  # Extra space between categories
    
    return doc

def create_review_excel(reviews, timestamp):
    """Create an Excel file with review results."""
        
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Review Results"
    
    # Headers
    headers = ["ID", "Requirement", "Description", "Status", "Comment", "Hint for Improvement"]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.font = Font(bold=True, color="FFFFFF")
        cell.fill = PatternFill(start_color="365F91", end_color="365F91", fill_type="solid")
        cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)
        cell.border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
    
    # Data rows
    for row, review in enumerate(reviews, 2):
        data = [
            review.get('id', ''),
            review.get('requirement', ''),
            review.get('description', ''),
            review.get('status', ''),
            review.get('comment', ''),
            review.get('hint', '')
        ]
        
        for col, value in enumerate(data, 1):
            cell = ws.cell(row=row, column=col, value=value)
            cell.alignment = Alignment(vertical="top", wrap_text=True)
            cell.border = Border(
                left=Side(style='thin'),
                right=Side(style='thin'),
                top=Side(style='thin'),
                bottom=Side(style='thin')
            )
            
            # Color code status column
            if col == 4:  # Status column
                status_lower = str(value).lower()
                if 'pass' in status_lower and 'fail' not in status_lower:
                    cell.fill = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")
                elif 'fail' in status_lower:
                    cell.fill = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")
                elif 'partial' in status_lower:
                    cell.fill = PatternFill(start_color="FFEB9C", end_color="FFEB9C", fill_type="solid")
    
    # Auto-adjust column widths
    for col in range(1, len(headers) + 1):
        column_letter = get_column_letter(col)
        max_length = 0
        for row in range(1, len(reviews) + 2):
            try:
                cell_value = str(ws[f"{column_letter}{row}"].value)
                if len(cell_value) > max_length:
                    max_length = len(cell_value)
            except:
                pass
        adjusted_width = min(max_length + 2, 50)  # Cap at 50 characters
        ws.column_dimensions[column_letter].width = adjusted_width
    
    # Summary sheet
    summary_ws = wb.create_sheet("Summary")
    
    # Summary data
    total_items = len(reviews)
    passed_items = len([r for r in reviews if r.get('status', '').lower() == 'pass'])
    failed_items = len([r for r in reviews if r.get('status', '').lower() == 'fail'])
    partial_items = len([r for r in reviews if 'partial' in r.get('status', '').lower()])
    
    summary_data = [
        ["Review Summary", ""],
        ["Generated on:", datetime.now().strftime('%Y-%m-%d %H:%M:%S')],
        ["Total Requirements Reviewed:", total_items],
        ["Passed:", passed_items],
        ["Failed:", failed_items],
        ["Partially Passed:", partial_items],
        ["Compliance Rate:", f"{(passed_items/total_items)*100:.1f}%" if total_items > 0 else "0%"]
    ]
    
    for row, (label, value) in enumerate(summary_data, 1):
        summary_ws.cell(row=row, column=1, value=label).font = Font(bold=True)
        summary_ws.cell(row=row, column=2, value=value)
    
    # Auto-adjust summary column widths
    for col in range(1, 3):
        column_letter = get_column_letter(col)
        summary_ws.column_dimensions[column_letter].width = 25
    
    return wb

@hook(priority=1)
def before_cat_sends_message(message, cat):
    """
    Hook: Detect if message contains a review result and save it as formatted documents.
    """
    content = message.get("content", "")
    
    # Trigger: Look for review pattern
    if not ("**ID:**" in content and "**Status:**" in content):
        return message  # Not a review result
    
    try:
        # Parse review content
        reviews = parse_review_content(content)
        
        if not reviews:
            log.warning("No review items found in the content")
            return message
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Paths
        plugin_folder = os.path.dirname(__file__)
        save_folder = os.path.join(plugin_folder, "generated_reviews")
        os.makedirs(save_folder, exist_ok=True)
        
        # Create Word document
        doc = create_review_docx(reviews, plugin_folder, timestamp)
        docx_filename = f"ItemDefinition_Review_{timestamp}.docx"
        docx_path = os.path.join(save_folder, docx_filename)
        doc.save(docx_path)
        log.info(f"‚úÖ Review document saved as DOCX: {docx_path}")
        
        # Create Excel file
        wb = create_review_excel(reviews, timestamp)
        excel_filename = f"ItemDefinition_Review_{timestamp}.xlsx"
        excel_path = os.path.join(save_folder, excel_filename)
        wb.save(excel_path)
        log.info(f"‚úÖ Review results saved as Excel: {excel_path}")
        
        # Update message to notify user
        message["content"] += f"\n\nüìÑ *Review documents generated:*\n- Word: `{docx_filename}`\n- Excel: `{excel_filename}`"
        
    except Exception as e:
        log.error(f"‚ùå Failed to save review documents: {e}")
        message["content"] += f"\n\n‚ö†Ô∏è *Failed to generate review documents:* {str(e)}"
    
    return message