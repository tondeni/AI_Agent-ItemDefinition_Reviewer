from cat.mad_hatter.decorators import hook
from docx import Document
from io import BytesIO, StringIO
import base64
import os
import csv
import zipfile
import re
import json
from datetime import datetime
from docx.enum.style import WD_STYLE_TYPE
from docx.shared import Pt
from docx.shared import Inches

# Hook: Export LLM output to .docx, .csv and package into .zip
@hook(priority=0)
def before_cat_sends_message(final_output, cat):
    """
    This hook runs after the LLM generates a response that includes a markdown-style table.
    It performs the following actions:
    
    1. Detects if the response contains a checklist review (based on presence of '|')
    2. Parses the markdown-style table from the LLM output
    3. Creates a structured Word (.docx) document with tables per item
    4. Builds a CSV file using ';' as delimiter for Excel compatibility
    5. Packages both files into a ZIP archive
    6. Returns the ZIP file to the user for download
    7. Saves the ZIP locally for future reference
    
    Args:
        final_output (dict): The final message to be sent to the user.
        cat (Cat): Cheshire Cat instance, used to access memory, settings, etc.
        
    Returns:
        dict: Updated final_output with downloadable ZIP file attached.
    """

  
    # Only process if the output contains a markdown-style table (i.e., has '|')
    if "|" in final_output.get("content", ""):
        print("ðŸ“¦ Packaging .docx and .csv into .zip...")

        # Get current plugin folder path
        plugin_folder = os.path.dirname(__file__)

        # Load checklist JSON data to enrich review with requirement descriptions and ISO clauses
        checklist = load_checklist(plugin_folder)
        checklist_items = checklist.get("items", [])
        checklist_map = {item["id"]: item for item in checklist_items}

        # Step 1: Parse markdown-style table from LLM output
        review_data = parse_markdown_table(final_output["content"])

        # Step 2: Create a new Word document
        doc = Document()
        create_custom_styles(doc)

        # === ADD HEADER TO ALL PAGES ===
        section = doc.sections[0]
        header = section.header
        # Create a 2x2 table in the header
        table = header.add_table(rows=2, cols=2, width=Inches(6))
        # Get cell references
        cell_logo = table.rows[0].cells[0]
        cell_title = table.rows[0].cells[1]

        # === LEFT CELL: Logo (if exists) ===
        image_path = os.path.join(plugin_folder, "templates", "logo.png")
        if os.path.exists(image_path):
            paragraph = cell_logo.paragraphs[0]
            run = paragraph.add_run()
            run.add_picture(image_path, width=Inches(1.5))  # Adjust size as needed
            cell_logo.width = Inches(1.5)

        # === RIGHT CELL: Title and subtitle ===
        title_paragraph = cell_title.paragraphs[0]
        title_run = title_paragraph.add_run("ISO 26262 Safety Compliance Review\nItem Definition Checklist Review")
        title_run.font.size = Pt(12)
        title_run.bold = True


        # === ADD FOOTER TO ALL PAGES ===
        footer = section.footer
        paragraph = footer.paragraphs[0]
        paragraph.text = "CONFIDENTIAL â€“ Generated by AI-FuSa Agent "
        paragraph.alignment = 1  # Centered
        paragraph.style = "Normal"
        run = paragraph.runs[0]
        run.font.size = Pt(9)
        run.italic = True

        # === FIRST PAGE ===
        doc.add_heading('ISO 26262 Part 3 - Item Definition Review Report', level=1)
        doc.add_paragraph("Item Definition Checklist Review", style="CustomTitle")
        doc.add_paragraph(f"Item: [ADD ITEM NAME HERE]", style="CustomSubtitle")
        doc.add_paragraph()  # Spacing
        # === PAGE BREAK ===
        doc.add_page_break()

        # Add main heading
        doc.add_heading('ISO 26262 Part 3 - Item Definition Review Report', level=1)

        # Loop through each item in the parsed LLM response
        for item in review_data:
            
            item_id = item.get("ID", "")
            checklist_item = checklist_map.get(item_id, {})
            category = checklist_item.get("category", "Uncategorized")

            # Add category heading and explanation only when it changes
            if not hasattr(before_cat_sends_message, "last_category") or before_cat_sends_message.last_category != category:
                doc.add_heading(category, level=2)
                add_section_explanation(doc, category)
                before_cat_sends_message.last_category = category

            # Create a table with 2 columns and N rows depending on content
            table = doc.add_table(rows=6, cols=2)
            table.style = 'Table Grid'

            # Set column widths
            for row in table.rows:
                row.cells[0].width = Pt(2.5 * 1440 / 72)  # ~1.5 inches wide
                row.cells[1].width = Pt(20.0 * 1440 / 72)  # ~10.5 inches wide

            def set_cell_text(cell, text, bold=False):
                paragraph = cell.paragraphs[0]
                run = paragraph.add_run(text)
                run.bold = bold
                run.font.size = Pt(10)

            set_cell_text(table.rows[0].cells[0], "Requirement", bold=True)
            set_cell_text(table.rows[0].cells[1], checklist_item.get("requirement", ""))

            set_cell_text(table.rows[1].cells[0], "Description", bold=True)
            set_cell_text(table.rows[1].cells[1], checklist_item.get("description", "N/A"))

            set_cell_text(table.rows[2].cells[0], "ISO Clause", bold=True)
            set_cell_text(table.rows[2].cells[1], checklist_item.get("iso_clause", "N/A"))

            set_cell_text(table.rows[3].cells[0], "Result", bold=True)
            set_cell_text(table.rows[3].cells[1], item.get("Status", "Not Reviewed"))

            set_cell_text(table.rows[4].cells[0], "Comment", bold=True)
            set_cell_text(table.rows[4].cells[1], item.get("Comment", ""))

            set_cell_text(table.rows[5].cells[0], "Hint for improvement", bold=True)
            set_cell_text(table.rows[5].cells[1], item.get("Hint for Improvement", "N/A"))

            # Add spacing after each item
            p = doc.add_paragraph()
            p.paragraph_format.space_after = Pt(0)
            p.paragraph_format.line_spacing = 1.0

        # Step 3: Save .docx to buffer (in-memory)
        doc_buffer = BytesIO()
        doc.save(doc_buffer)
        doc_buffer.seek(0)
        doc_bytes = doc_buffer.getvalue()
        doc_buffer.close()

        # Step 4: Build CSV content
        csv_buffer = StringIO()
        csv_writer = csv.writer(csv_buffer, delimiter=";")
        csv_writer.writerow(["ID", "Requirement", "Description", "Clause", "Status", "Comment", "Hint for Improvement"])

        # Populate CSV rows using both LLM output and checklist metadata
        for item in review_data:
            item_id = item.get("ID", "")
            req = item.get("Requirement", "")
            status = item.get("Status", "")
            comment = item.get("Comment", "")
            suggestion = item.get("Hint for Improvement", "")

            checklist_item = checklist_map.get(item_id, {})
            full_requirement = checklist_item.get("requirement", req)
            iso_clause = checklist_item.get("iso_clause", "N/A")
            description = checklist_item.get("description", "N/A")

            csv_writer.writerow([item_id, full_requirement, description, iso_clause, status, comment, suggestion])

        csv_content = csv_buffer.getvalue()
        csv_buffer.close()

        # Step 5: Package both files into a ZIP archive
        zip_buffer = BytesIO()
        with zipfile.ZipFile(zip_buffer, "w") as zip_file:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # Add .docx file to ZIP
            doc_filename = f"item_definition_review_{timestamp}.docx"
            zip_file.writestr(doc_filename, doc_bytes)

            # Add .csv file to ZIP
            csv_filename = f"item_definition_review_{timestamp}.csv"
            zip_file.writestr(csv_filename, csv_content)

        zip_buffer.seek(0)
        encoded_zip = base64.b64encode(zip_buffer.read()).decode("utf-8")
        zip_buffer.close()

        # Step 6: Save ZIP file to disk for local access
        exports_folder = os.path.join(plugin_folder, "exports")
        os.makedirs(exports_folder, exist_ok=True)

        zip_path = os.path.join(exports_folder, f"item_definition_review_{timestamp}.zip")

        with open(zip_path, "wb") as f:
            f.write(base64.b64decode(encoded_zip))

        print(f"ðŸ’¾ ZIP file saved at: {zip_path}")

        # # final_output["content"]= review_data

        # # Step 7: Attach ZIP file to chat response for download
        # final_output["file"] = {
        #     "name": f"item_definition_review_{timestamp}.zip",
        #     "content": encoded_zip,
        #     "type": "zip"
        # }

        # # Optional: Update chat message to confirm export
        # final_output["content"] = (
        #     "âœ… Review completed and exported.\n"
        #     "See attached `.zip` file containing:\n"
        #     "- `item_definition_review.docx`\n"
        #     "- `item_definition_review.csv`"
        # )

        # Build a human-readable summary of the checklist review
        summary_lines = [
            "ðŸ“‹ Checklist Review Summary",
            "| ID       | Requirement                                  | Status  |  Comment                | Hint                       |",
            "|----------| ---------------------------------------------| --------|-------------------------|----------------------------|"
        ]

        for item in review_data:
            req = item.get("Requirement", "")
            status = item.get("Status", "Not Reviewed")
            comment = item.get("Comment", "")
            suggestion = item.get("Hint for Improvement", "")

            summary_lines.append(f"| {item.get('ID', '')} | {req.ljust(7)} | {status.ljust(7)} | {comment.ljust(7)} | {suggestion.ljust(7)} |")

        summary_lines.append("")  # Add spacing

        # Combine all lines into a single string
        summary_text = "\n".join(summary_lines)

        # Update final output content
        final_output["content"] = (
            " Here below is the checklist review compiled for the Item Definition:\n\n\n"
            f"{summary_text}\n\n\n"
            "âœ… Detailed report has been generated and exported. \n"
            "See attached `.zip` file containing:\n"
            "- `item_definition_review.docx`\n"
            "- `item_definition_review.csv`"
        )

        return final_output

def parse_markdown_table(text):
    # Normalize line endings
    text = text.replace("\r\n", "\n").replace("\r", "\n")

    # Detect markdown tables
    table_pattern = re.compile(r"(\|.*\|\s*\|[-:]*[-|]\s*(?:\|.*\|[\s\d]*)+)", re.DOTALL)
    tables = table_pattern.findall(text)

    parsed_data = []

    for table_block in tables:
        lines = [line.strip() for line in table_block.split('\n') if line.strip()]
        if len(lines) < 2:
            continue

        raw_headers = [h.strip() for h in lines[0].split('|')]
        headers = raw_headers[1:-1]  # Remove empty first and last

        for line in lines[2:]:
            raw_cells = [c.strip() for c in line.split('|')]
            cells = raw_cells[1:-1]

            if not any(cells):
                continue

            row = dict(zip(headers, cells))
            parsed_data.append(row)

    return parsed_data

def load_checklist(plugin_folder):
    """
    Loads the ISO 26262 Part 3 compliance checklist from a JSON file.

    Args:
        plugin_folder (str): Path to the plugin folder.

    Returns:
        dict: Checklist data as a Python dictionary.

    Raises:
        FileNotFoundError: If the JSON file is missing.
        json.JSONDecodeError: If the JSON file has syntax errors.
    """
    checklist_path = os.path.join(plugin_folder, "checklists", "item_definition_checklist.json")
    
    try:
        with open(checklist_path, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"Checklist file not found at {checklist_path}")
    except json.JSONDecodeError as e:
        raise json.JSONDecodeError(f"Invalid JSON in checklist file: {e}", doc=e.doc, pos=e.pos)
    
# Helper Function: Add explanation text for each category
def add_section_explanation(doc, category):
    """
    Adds a brief explanation paragraph after each category heading in the Word document.
    """
    explanations = {
        "Identification and Classification": (
            "This section ensures that the item is uniquely identified within the system architecture or documentation "
            "and properly classified (e.g., as hardware, software, or a system function). This supports traceability from "
            "high-level safety goals down to detailed design elements. Clear identification also enables effective configuration "
            "management and version control throughout the development lifecycle. It is a foundational element for ensuring structured functional safety development."
        ),
        "Functional Description": (
            "This section describes the expected behavior of the item under all operating conditions, including normal, degraded, "
            "and fault modes. It includes definitions of interfaces, timing constraints, and performance requirements. A well-defined "
            "functional description is essential for identifying potential failure scenarios and serves as input to hazard analysis. It helps "
            "ensure that all relevant behaviors are considered when deriving safety requirements."
        ),
        "Safety-Related Attributes": (
            "This section captures key safety-related properties such as safety goals, mitigation strategies, diagnostic coverage, "
            "and safe state definitions. These attributes are derived from the Hazard Analysis and Risk Assessment (HARA) and form the basis "
            "of the functional safety concept. They guide the implementation of safety mechanisms and define how the item contributes to overall "
            "system safety. Proper documentation ensures alignment with ISO 26262 expectations for safety integrity."
        ),
        "Dependencies and Interactions": (
            "This section identifies internal and external dependencies, including interactions with other systems, environmental influences, "
            "and user inputs. Understanding these relationships is critical for defining correct assumptions and boundary conditions during development. "
            "It also supports the identification of potential interference or integration risks that could impact safety. Accurate documentation ensures robust "
            "interface management and system integration."
        ),
        "System Boundaries and Context": (
            "This section defines the physical and logical boundaries of the item, along with environmental conditions and design constraints. "
            "It clarifies where the item operates and under what limitations, such as temperature, vibration, or EMC exposure. These details ensure that "
            "the item is developed and validated under realistic assumptions. Defining this context early supports the creation of accurate test plans and operational profiles."
        ),
        "Review and Approval": (
            "This section confirms that a formal review process was followed and that all necessary approvals were obtained before finalizing the item definition. "
            "It verifies that review minutes, action items, and change records are documented and closed. Configuration management practices should also be applied to maintain "
            "document integrity. This ensures process compliance and provides an auditable trail for quality assurance and functional safety governance."
        )
    }

    explanation = explanations.get(category)
    if explanation:
        paragraph = doc.add_paragraph(explanation)
        paragraph.style = 'Normal'
        paragraph.alignment = 0  # Left-aligned
        paragraph.paragraph_format.space_after = Pt(12)
        paragraph.paragraph_format.line_spacing = 1.2

def create_custom_styles(doc):
    # Title style
    title_style = doc.styles.add_style("CustomTitle", WD_STYLE_TYPE.PARAGRAPH)
    title_style.base_style = doc.styles["Normal"]
    title_style.font.name = "QuickSand"
    title_style.font.size = Pt(24)
    title_style.font.bold = True
    title_style.paragraph_format.alignment = 1  # Centered
    title_style.paragraph_format.space_after = Pt(12)

    # Subtitle style
    subtitle_style = doc.styles.add_style("CustomSubtitle", WD_STYLE_TYPE.PARAGRAPH)
    subtitle_style.base_style = doc.styles["Normal"]
    subtitle_style.font.name = "QuickSand"
    subtitle_style.font.size = Pt(24)
    subtitle_style.font.italic = True
    title_style.paragraph_format.alignment = 1  # Centered
    subtitle_style.paragraph_format.space_after = Pt(12)